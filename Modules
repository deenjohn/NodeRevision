#How modules really works ?
Variables local to the module will be private, because the module is wrapped in a function by Node.js (see module wrapper).This function has arguments like __dirname , filename , exports - an empty object initially,module pointing to Module object, require.
#module.js
(function (exports, require, module, __filename, __dirname) {


#
The (.js) file extension is optional. Node.js will add it for you when attempting to load the file. It will also attempt to load the given module as a directory with an index file (index.js) or a package description (package.json).

#
module is an  empty obj .
module = {};
require returns a module.exports  , not "exports"

............................................................
#inside ""greet" folder there are 3 files : english.js , spanish.js , index.js

 // english.js 
        var greet = function() {
             console.log("hello");
         }//

#spanish.js

var greet = function() {
	console.log("hola");
}


#index.js
var english = require('./english');
var spanish = require('./spanish');

console.log("index file");

module.exports = {
	english: english,
	spanish: spanish	
};

....................................

#app.js.var greet = require('./greet'); 
greet.english();
greet.spanish();

// search for index.js or index.json file in greet folder by default 
but we can control this , all we need to do is add a package.json file in there and specify which file should be used to resolve this folder.
ex : learn-node $ echo '{ "name": "greet", "main": "start.js" }' > node_modules/find-me/package.json

.................................
#require.resolve
This behaves exactly the same as the main require function, but does not load the file.
> require.resolve('find-me');
		
Output :	'/Users/samer/learn-node/node_modules/find-me/start.js'

> require.resolve('not-there');
Output :	Error: Cannot find module 'not-there'

.................................

#
exports variable inside each module is just a reference to module.exports which manages the exported properties. When we reassign the exports variable, that reference is lost and we would be introducing a new variable instead of changing the module.exports object.
#Parent-child relation between files

#Require vs Readfile
require will read the file only once. Subsequent calls to require for the same file will return a cached copy. Not a good idea if you want to read a .json file that is continuously updated.
require is synchronous. If you have a very big JSON file, it will choke your event loop. You really need to use JSON.parse with fs.readFile.
http://stackoverflow.com/questions/5726729/how-to-parse-json-using-node-js?rq=1


 # circular modular dependency is allowed in Node.
 Partially loaded is used.
 
   	#loaded attribute on every module
	The module module uses the loaded attribute to track which modules have been loaded (true value) and which modules are still being loaded (false value).

.................................

#Requiring JSON files

config.json file:

{
  "host": "localhost",
  "port": 8080
}


const { host, port } = require('./config');
console.log(`Server will run at http://${host}:${port}`);


 
     
 #All modules will be cached
 doing require('file'); will load the file and run the code in it.
 

index.js
	var c = "deen"
	//exports.variable = c;
	console.log(c);

app.js
	console.log(new Date().getSeconds());
	require('./index.js');  //load the index file
	console.log(new Date().getSeconds());

node app.js > deen 















.................................

Resources :
1)Learn & understand node.js Tony alecia course
2)Samer byna :https://medium.freecodecamp.com/requiring-modules-in-node-js-everything-you-need-to-know-e7fbd119be8
3)Secrets of Javascript ninja : 
      chapter 5 "techniques for memoizing function" - essential for understanding "wrapping" and "caching" done by modules and require function
 














